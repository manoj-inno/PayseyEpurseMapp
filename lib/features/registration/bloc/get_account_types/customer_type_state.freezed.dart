// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'customer_type_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CustomerTypeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomerTypeStateCopyWith<$Res> {
  factory $CustomerTypeStateCopyWith(
          CustomerTypeState value, $Res Function(CustomerTypeState) then) =
      _$CustomerTypeStateCopyWithImpl<$Res, CustomerTypeState>;
}

/// @nodoc
class _$CustomerTypeStateCopyWithImpl<$Res, $Val extends CustomerTypeState>
    implements $CustomerTypeStateCopyWith<$Res> {
  _$CustomerTypeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CustomerTypeInitialImplCopyWith<$Res> {
  factory _$$CustomerTypeInitialImplCopyWith(_$CustomerTypeInitialImpl value,
          $Res Function(_$CustomerTypeInitialImpl) then) =
      __$$CustomerTypeInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CustomerTypeInitialImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$CustomerTypeInitialImpl>
    implements _$$CustomerTypeInitialImplCopyWith<$Res> {
  __$$CustomerTypeInitialImplCopyWithImpl(_$CustomerTypeInitialImpl _value,
      $Res Function(_$CustomerTypeInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CustomerTypeInitialImpl implements CustomerTypeInitial {
  const _$CustomerTypeInitialImpl();

  @override
  String toString() {
    return 'CustomerTypeState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomerTypeInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class CustomerTypeInitial implements CustomerTypeState {
  const factory CustomerTypeInitial() = _$CustomerTypeInitialImpl;
}

/// @nodoc
abstract class _$$CustomerTypeLoadingImplCopyWith<$Res> {
  factory _$$CustomerTypeLoadingImplCopyWith(_$CustomerTypeLoadingImpl value,
          $Res Function(_$CustomerTypeLoadingImpl) then) =
      __$$CustomerTypeLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CustomerTypeLoadingImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$CustomerTypeLoadingImpl>
    implements _$$CustomerTypeLoadingImplCopyWith<$Res> {
  __$$CustomerTypeLoadingImplCopyWithImpl(_$CustomerTypeLoadingImpl _value,
      $Res Function(_$CustomerTypeLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CustomerTypeLoadingImpl implements CustomerTypeLoading {
  const _$CustomerTypeLoadingImpl();

  @override
  String toString() {
    return 'CustomerTypeState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomerTypeLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class CustomerTypeLoading implements CustomerTypeState {
  const factory CustomerTypeLoading() = _$CustomerTypeLoadingImpl;
}

/// @nodoc
abstract class _$$CustomerTypeLoadedImplCopyWith<$Res> {
  factory _$$CustomerTypeLoadedImplCopyWith(_$CustomerTypeLoadedImpl value,
          $Res Function(_$CustomerTypeLoadedImpl) then) =
      __$$CustomerTypeLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<CustomerTypeEntity> customerTypes});
}

/// @nodoc
class __$$CustomerTypeLoadedImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$CustomerTypeLoadedImpl>
    implements _$$CustomerTypeLoadedImplCopyWith<$Res> {
  __$$CustomerTypeLoadedImplCopyWithImpl(_$CustomerTypeLoadedImpl _value,
      $Res Function(_$CustomerTypeLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? customerTypes = null,
  }) {
    return _then(_$CustomerTypeLoadedImpl(
      customerTypes: null == customerTypes
          ? _value._customerTypes
          : customerTypes // ignore: cast_nullable_to_non_nullable
              as List<CustomerTypeEntity>,
    ));
  }
}

/// @nodoc

class _$CustomerTypeLoadedImpl implements CustomerTypeLoaded {
  const _$CustomerTypeLoadedImpl(
      {required final List<CustomerTypeEntity> customerTypes})
      : _customerTypes = customerTypes;

  final List<CustomerTypeEntity> _customerTypes;
  @override
  List<CustomerTypeEntity> get customerTypes {
    if (_customerTypes is EqualUnmodifiableListView) return _customerTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_customerTypes);
  }

  @override
  String toString() {
    return 'CustomerTypeState.loaded(customerTypes: $customerTypes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomerTypeLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._customerTypes, _customerTypes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_customerTypes));

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomerTypeLoadedImplCopyWith<_$CustomerTypeLoadedImpl> get copyWith =>
      __$$CustomerTypeLoadedImplCopyWithImpl<_$CustomerTypeLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return loaded(customerTypes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return loaded?.call(customerTypes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(customerTypes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class CustomerTypeLoaded implements CustomerTypeState {
  const factory CustomerTypeLoaded(
          {required final List<CustomerTypeEntity> customerTypes}) =
      _$CustomerTypeLoadedImpl;

  List<CustomerTypeEntity> get customerTypes;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CustomerTypeLoadedImplCopyWith<_$CustomerTypeLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CustomerTypeErrorImplCopyWith<$Res> {
  factory _$$CustomerTypeErrorImplCopyWith(_$CustomerTypeErrorImpl value,
          $Res Function(_$CustomerTypeErrorImpl) then) =
      __$$CustomerTypeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CustomerTypeErrorImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$CustomerTypeErrorImpl>
    implements _$$CustomerTypeErrorImplCopyWith<$Res> {
  __$$CustomerTypeErrorImplCopyWithImpl(_$CustomerTypeErrorImpl _value,
      $Res Function(_$CustomerTypeErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CustomerTypeErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CustomerTypeErrorImpl implements CustomerTypeError {
  const _$CustomerTypeErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomerTypeErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomerTypeErrorImplCopyWith<_$CustomerTypeErrorImpl> get copyWith =>
      __$$CustomerTypeErrorImplCopyWithImpl<_$CustomerTypeErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class CustomerTypeError implements CustomerTypeState {
  const factory CustomerTypeError({required final String message}) =
      _$CustomerTypeErrorImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CustomerTypeErrorImplCopyWith<_$CustomerTypeErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CustomerTypeUnavailableImplCopyWith<$Res> {
  factory _$$CustomerTypeUnavailableImplCopyWith(
          _$CustomerTypeUnavailableImpl value,
          $Res Function(_$CustomerTypeUnavailableImpl) then) =
      __$$CustomerTypeUnavailableImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CustomerTypeUnavailableImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$CustomerTypeUnavailableImpl>
    implements _$$CustomerTypeUnavailableImplCopyWith<$Res> {
  __$$CustomerTypeUnavailableImplCopyWithImpl(
      _$CustomerTypeUnavailableImpl _value,
      $Res Function(_$CustomerTypeUnavailableImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CustomerTypeUnavailableImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CustomerTypeUnavailableImpl implements CustomerTypeUnavailable {
  const _$CustomerTypeUnavailableImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.unavailable(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomerTypeUnavailableImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomerTypeUnavailableImplCopyWith<_$CustomerTypeUnavailableImpl>
      get copyWith => __$$CustomerTypeUnavailableImplCopyWithImpl<
          _$CustomerTypeUnavailableImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return unavailable(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return unavailable?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (unavailable != null) {
      return unavailable(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return unavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return unavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (unavailable != null) {
      return unavailable(this);
    }
    return orElse();
  }
}

abstract class CustomerTypeUnavailable implements CustomerTypeState {
  const factory CustomerTypeUnavailable({required final String message}) =
      _$CustomerTypeUnavailableImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CustomerTypeUnavailableImplCopyWith<_$CustomerTypeUnavailableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountTypeInitialStateImplCopyWith<$Res> {
  factory _$$AccountTypeInitialStateImplCopyWith(
          _$AccountTypeInitialStateImpl value,
          $Res Function(_$AccountTypeInitialStateImpl) then) =
      __$$AccountTypeInitialStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountTypeInitialStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$AccountTypeInitialStateImpl>
    implements _$$AccountTypeInitialStateImplCopyWith<$Res> {
  __$$AccountTypeInitialStateImplCopyWithImpl(
      _$AccountTypeInitialStateImpl _value,
      $Res Function(_$AccountTypeInitialStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AccountTypeInitialStateImpl implements AccountTypeInitialState {
  const _$AccountTypeInitialStateImpl();

  @override
  String toString() {
    return 'CustomerTypeState.accountTypeInitial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountTypeInitialStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountTypeInitial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountTypeInitial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeInitial != null) {
      return accountTypeInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountTypeInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountTypeInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeInitial != null) {
      return accountTypeInitial(this);
    }
    return orElse();
  }
}

abstract class AccountTypeInitialState implements CustomerTypeState {
  const factory AccountTypeInitialState() = _$AccountTypeInitialStateImpl;
}

/// @nodoc
abstract class _$$AccountTypeLoadingStateImplCopyWith<$Res> {
  factory _$$AccountTypeLoadingStateImplCopyWith(
          _$AccountTypeLoadingStateImpl value,
          $Res Function(_$AccountTypeLoadingStateImpl) then) =
      __$$AccountTypeLoadingStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountTypeLoadingStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$AccountTypeLoadingStateImpl>
    implements _$$AccountTypeLoadingStateImplCopyWith<$Res> {
  __$$AccountTypeLoadingStateImplCopyWithImpl(
      _$AccountTypeLoadingStateImpl _value,
      $Res Function(_$AccountTypeLoadingStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AccountTypeLoadingStateImpl implements AccountTypeLoadingState {
  const _$AccountTypeLoadingStateImpl();

  @override
  String toString() {
    return 'CustomerTypeState.accountTypeLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountTypeLoadingStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountTypeLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountTypeLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeLoading != null) {
      return accountTypeLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountTypeLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountTypeLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeLoading != null) {
      return accountTypeLoading(this);
    }
    return orElse();
  }
}

abstract class AccountTypeLoadingState implements CustomerTypeState {
  const factory AccountTypeLoadingState() = _$AccountTypeLoadingStateImpl;
}

/// @nodoc
abstract class _$$AccountTypeLoadedStateImplCopyWith<$Res> {
  factory _$$AccountTypeLoadedStateImplCopyWith(
          _$AccountTypeLoadedStateImpl value,
          $Res Function(_$AccountTypeLoadedStateImpl) then) =
      __$$AccountTypeLoadedStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<AccountTypeEntity> accountTypes});
}

/// @nodoc
class __$$AccountTypeLoadedStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$AccountTypeLoadedStateImpl>
    implements _$$AccountTypeLoadedStateImplCopyWith<$Res> {
  __$$AccountTypeLoadedStateImplCopyWithImpl(
      _$AccountTypeLoadedStateImpl _value,
      $Res Function(_$AccountTypeLoadedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountTypes = null,
  }) {
    return _then(_$AccountTypeLoadedStateImpl(
      accountTypes: null == accountTypes
          ? _value._accountTypes
          : accountTypes // ignore: cast_nullable_to_non_nullable
              as List<AccountTypeEntity>,
    ));
  }
}

/// @nodoc

class _$AccountTypeLoadedStateImpl implements AccountTypeLoadedState {
  const _$AccountTypeLoadedStateImpl(
      {required final List<AccountTypeEntity> accountTypes})
      : _accountTypes = accountTypes;

  final List<AccountTypeEntity> _accountTypes;
  @override
  List<AccountTypeEntity> get accountTypes {
    if (_accountTypes is EqualUnmodifiableListView) return _accountTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accountTypes);
  }

  @override
  String toString() {
    return 'CustomerTypeState.accountTypeLoaded(accountTypes: $accountTypes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountTypeLoadedStateImpl &&
            const DeepCollectionEquality()
                .equals(other._accountTypes, _accountTypes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_accountTypes));

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountTypeLoadedStateImplCopyWith<_$AccountTypeLoadedStateImpl>
      get copyWith => __$$AccountTypeLoadedStateImplCopyWithImpl<
          _$AccountTypeLoadedStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountTypeLoaded(accountTypes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountTypeLoaded?.call(accountTypes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeLoaded != null) {
      return accountTypeLoaded(accountTypes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountTypeLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountTypeLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeLoaded != null) {
      return accountTypeLoaded(this);
    }
    return orElse();
  }
}

abstract class AccountTypeLoadedState implements CustomerTypeState {
  const factory AccountTypeLoadedState(
          {required final List<AccountTypeEntity> accountTypes}) =
      _$AccountTypeLoadedStateImpl;

  List<AccountTypeEntity> get accountTypes;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountTypeLoadedStateImplCopyWith<_$AccountTypeLoadedStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountTypeUnavailableImplCopyWith<$Res> {
  factory _$$AccountTypeUnavailableImplCopyWith(
          _$AccountTypeUnavailableImpl value,
          $Res Function(_$AccountTypeUnavailableImpl) then) =
      __$$AccountTypeUnavailableImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$AccountTypeUnavailableImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$AccountTypeUnavailableImpl>
    implements _$$AccountTypeUnavailableImplCopyWith<$Res> {
  __$$AccountTypeUnavailableImplCopyWithImpl(
      _$AccountTypeUnavailableImpl _value,
      $Res Function(_$AccountTypeUnavailableImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$AccountTypeUnavailableImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AccountTypeUnavailableImpl implements AccountTypeUnavailable {
  const _$AccountTypeUnavailableImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.accountTypeUnavailable(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountTypeUnavailableImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountTypeUnavailableImplCopyWith<_$AccountTypeUnavailableImpl>
      get copyWith => __$$AccountTypeUnavailableImplCopyWithImpl<
          _$AccountTypeUnavailableImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountTypeUnavailable(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountTypeUnavailable?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeUnavailable != null) {
      return accountTypeUnavailable(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountTypeUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountTypeUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeUnavailable != null) {
      return accountTypeUnavailable(this);
    }
    return orElse();
  }
}

abstract class AccountTypeUnavailable implements CustomerTypeState {
  const factory AccountTypeUnavailable({required final String message}) =
      _$AccountTypeUnavailableImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountTypeUnavailableImplCopyWith<_$AccountTypeUnavailableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountTypeErrorStateImplCopyWith<$Res> {
  factory _$$AccountTypeErrorStateImplCopyWith(
          _$AccountTypeErrorStateImpl value,
          $Res Function(_$AccountTypeErrorStateImpl) then) =
      __$$AccountTypeErrorStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$AccountTypeErrorStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res, _$AccountTypeErrorStateImpl>
    implements _$$AccountTypeErrorStateImplCopyWith<$Res> {
  __$$AccountTypeErrorStateImplCopyWithImpl(_$AccountTypeErrorStateImpl _value,
      $Res Function(_$AccountTypeErrorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$AccountTypeErrorStateImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AccountTypeErrorStateImpl implements AccountTypeErrorState {
  const _$AccountTypeErrorStateImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.accountTypeError(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountTypeErrorStateImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountTypeErrorStateImplCopyWith<_$AccountTypeErrorStateImpl>
      get copyWith => __$$AccountTypeErrorStateImplCopyWithImpl<
          _$AccountTypeErrorStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountTypeError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountTypeError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeError != null) {
      return accountTypeError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountTypeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountTypeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountTypeError != null) {
      return accountTypeError(this);
    }
    return orElse();
  }
}

abstract class AccountTypeErrorState implements CustomerTypeState {
  const factory AccountTypeErrorState({required final String message}) =
      _$AccountTypeErrorStateImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountTypeErrorStateImplCopyWith<_$AccountTypeErrorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountSubTypeInitialStateImplCopyWith<$Res> {
  factory _$$AccountSubTypeInitialStateImplCopyWith(
          _$AccountSubTypeInitialStateImpl value,
          $Res Function(_$AccountSubTypeInitialStateImpl) then) =
      __$$AccountSubTypeInitialStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountSubTypeInitialStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res,
        _$AccountSubTypeInitialStateImpl>
    implements _$$AccountSubTypeInitialStateImplCopyWith<$Res> {
  __$$AccountSubTypeInitialStateImplCopyWithImpl(
      _$AccountSubTypeInitialStateImpl _value,
      $Res Function(_$AccountSubTypeInitialStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AccountSubTypeInitialStateImpl implements AccountSubTypeInitialState {
  const _$AccountSubTypeInitialStateImpl();

  @override
  String toString() {
    return 'CustomerTypeState.accountSubTypeInitial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountSubTypeInitialStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountSubTypeInitial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountSubTypeInitial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeInitial != null) {
      return accountSubTypeInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountSubTypeInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountSubTypeInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeInitial != null) {
      return accountSubTypeInitial(this);
    }
    return orElse();
  }
}

abstract class AccountSubTypeInitialState implements CustomerTypeState {
  const factory AccountSubTypeInitialState() = _$AccountSubTypeInitialStateImpl;
}

/// @nodoc
abstract class _$$AccountSubTypeLoadingStateImplCopyWith<$Res> {
  factory _$$AccountSubTypeLoadingStateImplCopyWith(
          _$AccountSubTypeLoadingStateImpl value,
          $Res Function(_$AccountSubTypeLoadingStateImpl) then) =
      __$$AccountSubTypeLoadingStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountSubTypeLoadingStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res,
        _$AccountSubTypeLoadingStateImpl>
    implements _$$AccountSubTypeLoadingStateImplCopyWith<$Res> {
  __$$AccountSubTypeLoadingStateImplCopyWithImpl(
      _$AccountSubTypeLoadingStateImpl _value,
      $Res Function(_$AccountSubTypeLoadingStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AccountSubTypeLoadingStateImpl implements AccountSubTypeLoadingState {
  const _$AccountSubTypeLoadingStateImpl();

  @override
  String toString() {
    return 'CustomerTypeState.accountSubTypeLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountSubTypeLoadingStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountSubTypeLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountSubTypeLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeLoading != null) {
      return accountSubTypeLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountSubTypeLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountSubTypeLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeLoading != null) {
      return accountSubTypeLoading(this);
    }
    return orElse();
  }
}

abstract class AccountSubTypeLoadingState implements CustomerTypeState {
  const factory AccountSubTypeLoadingState() = _$AccountSubTypeLoadingStateImpl;
}

/// @nodoc
abstract class _$$AccountSubTypeLoadedStateImplCopyWith<$Res> {
  factory _$$AccountSubTypeLoadedStateImplCopyWith(
          _$AccountSubTypeLoadedStateImpl value,
          $Res Function(_$AccountSubTypeLoadedStateImpl) then) =
      __$$AccountSubTypeLoadedStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<AccountSubTypeEntity> accountSubTypes});
}

/// @nodoc
class __$$AccountSubTypeLoadedStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res,
        _$AccountSubTypeLoadedStateImpl>
    implements _$$AccountSubTypeLoadedStateImplCopyWith<$Res> {
  __$$AccountSubTypeLoadedStateImplCopyWithImpl(
      _$AccountSubTypeLoadedStateImpl _value,
      $Res Function(_$AccountSubTypeLoadedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? accountSubTypes = null,
  }) {
    return _then(_$AccountSubTypeLoadedStateImpl(
      accountSubTypes: null == accountSubTypes
          ? _value._accountSubTypes
          : accountSubTypes // ignore: cast_nullable_to_non_nullable
              as List<AccountSubTypeEntity>,
    ));
  }
}

/// @nodoc

class _$AccountSubTypeLoadedStateImpl implements AccountSubTypeLoadedState {
  const _$AccountSubTypeLoadedStateImpl(
      {required final List<AccountSubTypeEntity> accountSubTypes})
      : _accountSubTypes = accountSubTypes;

  final List<AccountSubTypeEntity> _accountSubTypes;
  @override
  List<AccountSubTypeEntity> get accountSubTypes {
    if (_accountSubTypes is EqualUnmodifiableListView) return _accountSubTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accountSubTypes);
  }

  @override
  String toString() {
    return 'CustomerTypeState.accountSubTypeLoaded(accountSubTypes: $accountSubTypes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountSubTypeLoadedStateImpl &&
            const DeepCollectionEquality()
                .equals(other._accountSubTypes, _accountSubTypes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_accountSubTypes));

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountSubTypeLoadedStateImplCopyWith<_$AccountSubTypeLoadedStateImpl>
      get copyWith => __$$AccountSubTypeLoadedStateImplCopyWithImpl<
          _$AccountSubTypeLoadedStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountSubTypeLoaded(accountSubTypes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountSubTypeLoaded?.call(accountSubTypes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeLoaded != null) {
      return accountSubTypeLoaded(accountSubTypes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountSubTypeLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountSubTypeLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeLoaded != null) {
      return accountSubTypeLoaded(this);
    }
    return orElse();
  }
}

abstract class AccountSubTypeLoadedState implements CustomerTypeState {
  const factory AccountSubTypeLoadedState(
          {required final List<AccountSubTypeEntity> accountSubTypes}) =
      _$AccountSubTypeLoadedStateImpl;

  List<AccountSubTypeEntity> get accountSubTypes;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountSubTypeLoadedStateImplCopyWith<_$AccountSubTypeLoadedStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountSubTypeUnavailableImplCopyWith<$Res> {
  factory _$$AccountSubTypeUnavailableImplCopyWith(
          _$AccountSubTypeUnavailableImpl value,
          $Res Function(_$AccountSubTypeUnavailableImpl) then) =
      __$$AccountSubTypeUnavailableImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$AccountSubTypeUnavailableImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res,
        _$AccountSubTypeUnavailableImpl>
    implements _$$AccountSubTypeUnavailableImplCopyWith<$Res> {
  __$$AccountSubTypeUnavailableImplCopyWithImpl(
      _$AccountSubTypeUnavailableImpl _value,
      $Res Function(_$AccountSubTypeUnavailableImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$AccountSubTypeUnavailableImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AccountSubTypeUnavailableImpl implements AccountSubTypeUnavailable {
  const _$AccountSubTypeUnavailableImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.accountSubTypeUnavailable(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountSubTypeUnavailableImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountSubTypeUnavailableImplCopyWith<_$AccountSubTypeUnavailableImpl>
      get copyWith => __$$AccountSubTypeUnavailableImplCopyWithImpl<
          _$AccountSubTypeUnavailableImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountSubTypeUnavailable(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountSubTypeUnavailable?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeUnavailable != null) {
      return accountSubTypeUnavailable(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountSubTypeUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountSubTypeUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeUnavailable != null) {
      return accountSubTypeUnavailable(this);
    }
    return orElse();
  }
}

abstract class AccountSubTypeUnavailable implements CustomerTypeState {
  const factory AccountSubTypeUnavailable({required final String message}) =
      _$AccountSubTypeUnavailableImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountSubTypeUnavailableImplCopyWith<_$AccountSubTypeUnavailableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountSubTypeErrorStateImplCopyWith<$Res> {
  factory _$$AccountSubTypeErrorStateImplCopyWith(
          _$AccountSubTypeErrorStateImpl value,
          $Res Function(_$AccountSubTypeErrorStateImpl) then) =
      __$$AccountSubTypeErrorStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$AccountSubTypeErrorStateImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res,
        _$AccountSubTypeErrorStateImpl>
    implements _$$AccountSubTypeErrorStateImplCopyWith<$Res> {
  __$$AccountSubTypeErrorStateImplCopyWithImpl(
      _$AccountSubTypeErrorStateImpl _value,
      $Res Function(_$AccountSubTypeErrorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$AccountSubTypeErrorStateImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AccountSubTypeErrorStateImpl implements AccountSubTypeErrorState {
  const _$AccountSubTypeErrorStateImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.accountSubTypeError(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountSubTypeErrorStateImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountSubTypeErrorStateImplCopyWith<_$AccountSubTypeErrorStateImpl>
      get copyWith => __$$AccountSubTypeErrorStateImplCopyWithImpl<
          _$AccountSubTypeErrorStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return accountSubTypeError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return accountSubTypeError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeError != null) {
      return accountSubTypeError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return accountSubTypeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return accountSubTypeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (accountSubTypeError != null) {
      return accountSubTypeError(this);
    }
    return orElse();
  }
}

abstract class AccountSubTypeErrorState implements CustomerTypeState {
  const factory AccountSubTypeErrorState({required final String message}) =
      _$AccountSubTypeErrorStateImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountSubTypeErrorStateImplCopyWith<_$AccountSubTypeErrorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CustomerTypeServerDownErrorImplCopyWith<$Res> {
  factory _$$CustomerTypeServerDownErrorImplCopyWith(
          _$CustomerTypeServerDownErrorImpl value,
          $Res Function(_$CustomerTypeServerDownErrorImpl) then) =
      __$$CustomerTypeServerDownErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CustomerTypeServerDownErrorImplCopyWithImpl<$Res>
    extends _$CustomerTypeStateCopyWithImpl<$Res,
        _$CustomerTypeServerDownErrorImpl>
    implements _$$CustomerTypeServerDownErrorImplCopyWith<$Res> {
  __$$CustomerTypeServerDownErrorImplCopyWithImpl(
      _$CustomerTypeServerDownErrorImpl _value,
      $Res Function(_$CustomerTypeServerDownErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CustomerTypeServerDownErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CustomerTypeServerDownErrorImpl implements CustomerTypeServerDownError {
  const _$CustomerTypeServerDownErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'CustomerTypeState.serverDownError(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomerTypeServerDownErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomerTypeServerDownErrorImplCopyWith<_$CustomerTypeServerDownErrorImpl>
      get copyWith => __$$CustomerTypeServerDownErrorImplCopyWithImpl<
          _$CustomerTypeServerDownErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<CustomerTypeEntity> customerTypes) loaded,
    required TResult Function(String message) error,
    required TResult Function(String message) unavailable,
    required TResult Function() accountTypeInitial,
    required TResult Function() accountTypeLoading,
    required TResult Function(List<AccountTypeEntity> accountTypes)
        accountTypeLoaded,
    required TResult Function(String message) accountTypeUnavailable,
    required TResult Function(String message) accountTypeError,
    required TResult Function() accountSubTypeInitial,
    required TResult Function() accountSubTypeLoading,
    required TResult Function(List<AccountSubTypeEntity> accountSubTypes)
        accountSubTypeLoaded,
    required TResult Function(String message) accountSubTypeUnavailable,
    required TResult Function(String message) accountSubTypeError,
    required TResult Function(String message) serverDownError,
  }) {
    return serverDownError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult? Function(String message)? error,
    TResult? Function(String message)? unavailable,
    TResult? Function()? accountTypeInitial,
    TResult? Function()? accountTypeLoading,
    TResult? Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult? Function(String message)? accountTypeUnavailable,
    TResult? Function(String message)? accountTypeError,
    TResult? Function()? accountSubTypeInitial,
    TResult? Function()? accountSubTypeLoading,
    TResult? Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult? Function(String message)? accountSubTypeUnavailable,
    TResult? Function(String message)? accountSubTypeError,
    TResult? Function(String message)? serverDownError,
  }) {
    return serverDownError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<CustomerTypeEntity> customerTypes)? loaded,
    TResult Function(String message)? error,
    TResult Function(String message)? unavailable,
    TResult Function()? accountTypeInitial,
    TResult Function()? accountTypeLoading,
    TResult Function(List<AccountTypeEntity> accountTypes)? accountTypeLoaded,
    TResult Function(String message)? accountTypeUnavailable,
    TResult Function(String message)? accountTypeError,
    TResult Function()? accountSubTypeInitial,
    TResult Function()? accountSubTypeLoading,
    TResult Function(List<AccountSubTypeEntity> accountSubTypes)?
        accountSubTypeLoaded,
    TResult Function(String message)? accountSubTypeUnavailable,
    TResult Function(String message)? accountSubTypeError,
    TResult Function(String message)? serverDownError,
    required TResult orElse(),
  }) {
    if (serverDownError != null) {
      return serverDownError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CustomerTypeInitial value) initial,
    required TResult Function(CustomerTypeLoading value) loading,
    required TResult Function(CustomerTypeLoaded value) loaded,
    required TResult Function(CustomerTypeError value) error,
    required TResult Function(CustomerTypeUnavailable value) unavailable,
    required TResult Function(AccountTypeInitialState value) accountTypeInitial,
    required TResult Function(AccountTypeLoadingState value) accountTypeLoading,
    required TResult Function(AccountTypeLoadedState value) accountTypeLoaded,
    required TResult Function(AccountTypeUnavailable value)
        accountTypeUnavailable,
    required TResult Function(AccountTypeErrorState value) accountTypeError,
    required TResult Function(AccountSubTypeInitialState value)
        accountSubTypeInitial,
    required TResult Function(AccountSubTypeLoadingState value)
        accountSubTypeLoading,
    required TResult Function(AccountSubTypeLoadedState value)
        accountSubTypeLoaded,
    required TResult Function(AccountSubTypeUnavailable value)
        accountSubTypeUnavailable,
    required TResult Function(AccountSubTypeErrorState value)
        accountSubTypeError,
    required TResult Function(CustomerTypeServerDownError value)
        serverDownError,
  }) {
    return serverDownError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CustomerTypeInitial value)? initial,
    TResult? Function(CustomerTypeLoading value)? loading,
    TResult? Function(CustomerTypeLoaded value)? loaded,
    TResult? Function(CustomerTypeError value)? error,
    TResult? Function(CustomerTypeUnavailable value)? unavailable,
    TResult? Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult? Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult? Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult? Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult? Function(AccountTypeErrorState value)? accountTypeError,
    TResult? Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult? Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult? Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult? Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult? Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult? Function(CustomerTypeServerDownError value)? serverDownError,
  }) {
    return serverDownError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CustomerTypeInitial value)? initial,
    TResult Function(CustomerTypeLoading value)? loading,
    TResult Function(CustomerTypeLoaded value)? loaded,
    TResult Function(CustomerTypeError value)? error,
    TResult Function(CustomerTypeUnavailable value)? unavailable,
    TResult Function(AccountTypeInitialState value)? accountTypeInitial,
    TResult Function(AccountTypeLoadingState value)? accountTypeLoading,
    TResult Function(AccountTypeLoadedState value)? accountTypeLoaded,
    TResult Function(AccountTypeUnavailable value)? accountTypeUnavailable,
    TResult Function(AccountTypeErrorState value)? accountTypeError,
    TResult Function(AccountSubTypeInitialState value)? accountSubTypeInitial,
    TResult Function(AccountSubTypeLoadingState value)? accountSubTypeLoading,
    TResult Function(AccountSubTypeLoadedState value)? accountSubTypeLoaded,
    TResult Function(AccountSubTypeUnavailable value)?
        accountSubTypeUnavailable,
    TResult Function(AccountSubTypeErrorState value)? accountSubTypeError,
    TResult Function(CustomerTypeServerDownError value)? serverDownError,
    required TResult orElse(),
  }) {
    if (serverDownError != null) {
      return serverDownError(this);
    }
    return orElse();
  }
}

abstract class CustomerTypeServerDownError implements CustomerTypeState {
  const factory CustomerTypeServerDownError({required final String message}) =
      _$CustomerTypeServerDownErrorImpl;

  String get message;

  /// Create a copy of CustomerTypeState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CustomerTypeServerDownErrorImplCopyWith<_$CustomerTypeServerDownErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
